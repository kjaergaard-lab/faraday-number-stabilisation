# Number stabilisation through Faraday Rotation

In ultracold atomic physics experiments, the number of atoms in a sample of atoms at a given temperature typically fluctuates between cycles of the experiment.  At best, this increases the amount of data that needs to be acquired to reach a given level of precision in measuring physical quantities.  At worst, fluctuations obscure interesting and/or important physics.  [Previous work by the group of J. Arlt in Denmark](https://link.aps.org/doi/10.1103/PhysRevLett.117.073604) has used dark-field Faraday imaging to non-destructively measure the number of atoms in a sample and then stabilise that number to below the shot-noise limit.  While impressive, it requires an expensive camera to make these measurements, and the use of the camera means that it can only make a measurement every 7 ms.  

[In our work](https://arxiv.org/abs/2102.01773), we have replaced the camera with a pair of avalanche photo-detectors (APDs) to simplify the setup and reduce the cycle time between measurements, which allows us to use an iterative scheme for stabilising the number of atoms.  Setup details can be found in the previous link, but, in short, we use a Red Pitaya FPGA development board to record the voltages produced by the APDs and convert them on-the-fly to a weighted ratio that is insensitive to changes in optical power or APD gain.  This ratio is then proportional to the number of atoms in the sample.

This repository consists of the VHDL source code, as well as a TCL script, for building the FPGA architecture which acquires and processes the APD signals, pulses on the microwave control, and handles the feedback algorithm.  To make it easier to use, a suite of MATLAB classes has been developed that allows for control of the FPGA, and much of this control can be handled via a MATLAB GUI.  Communication between MATLAB and the FPGA is done through the TCP/IP protocol with a Python-based socket server running on the Red Pitaya.  Through this combination of MATLAB and Python, parameters related to the acquisition and feedback can be set, and data from the FPGA can retrieved.

# Overview of FPGA behaviour

The Red Pitaya (RP) expects to have its ADCs connected to the APDs measuring the ouput signals of the polarimeter.  Furthermore, the RP needs to have a rising-edge trigger signal connected to the first pin on the `ext_i` bus, and the output pulse signals associated with lasers L and L' (the so-called 'signal' and 'auxiliary' lines) need to be connected to their respective AOMs.  A shutter output signal is also available if needed.  Finally, there is a microwave output signal that needs to be connected to an appropriate microwave switch.

## Signal acquisition and computation

When the RP receives a rising-edge trigger signal, it immediately triggers the pulse generators (`PulseGen.vhd`) on the signal and auxiliary lines.  These pulse generators have a variable, 32-bit delay counter that allows the auxiliary pulse to be delayed relative to the signal pulse.  The pulses have a user-defined period (32 bits) and pulse width (16 bits), with a programmable number of pulses (16 bits).  These pulse signals are routed to both the output signals to control the AOMs as well as to the next module, `QuickAvg.vhd`.

The `QuickAvg.vhd` module performs a quick, sliding, non-overlapping average of the input ADC signals with the number of samples to average being a power of 2.  The user can set the exponent to essentially downsample the data by more or less points.  On the rising edge of the pulse signal, the module first waits for a programmable delay (14 bits) before starting the averaging process.  This delay is used to account for the non-zero propagation delay of signals from the RP to the associated physical control boxes, as well as the finite travel time of the acoustic waves through the AOMs.  The signal and auxiliary lines can have different delays.  The `QuickAvg` module sums up 2^N points, where N is a 4 bit integer, and then divides by 2^N by shifting the sum N bits to the right.  This occurs for a fixed number of samples (user programmable with 14 bits) before the process stops and waits for the next pulse.  Once the data has been averaged, it is presented on the output data port of the module along with a one clock-cycle active-high valid signal.  For debugging purposes, the first 4096 averaged values on each channel are saved to a block RAM for later retrieval.

The averaged signal is then passed to the `IntegrateADCData.vhd` module which sums the averaged data two windows before subtracting these two sums.  The first summation region should occur when light is present on the APD, and the second summation region should occur when there is no light.  The difference between these then allows for a measure of the signal relative to a possibly changing baseline voltage on the RP.  The regions of summation and subtraction are specified by 11-bit starting points `sumStart` and `subStart`, respectively, with an 10 bit width `width` that is common between them.  The width is common so that one does not need to implement division to ensure that the scales of the summation and subtraction regions are the same.  Once the subtraction has occurred, this data is presented on the output of the module with a single clock-cycle active-high valid signal.  Like the averaged data, the integrated data is also saved in a block RAM for later retrieval.

The integrated data on both the signal and auxiliary lines are then fed into the module `ComputeSignal.vhd` which waits until it gets valid signals from both the signal and auxiliary lines and then proceeds to compute the signal R (as in Eq. 4 in the arXiv paper).  This involves two multiplications and one division, and has a latency of nearly 100 clock cycles.  The ratio value R is computed to 16 bits of precision, and is presented on the output along with a valid signal.  R is saved in a block memory for later retrieval.

## Feedback

