# Number stabilisation through Faraday Rotation

In ultracold atomic physics experiments, the number of atoms in a sample of atoms at a given temperature typically fluctuates between cycles of the experiment.  At best, this increases the amount of data that needs to be acquired to reach a given level of precision in measuring physical quantities.  At worst, fluctuations obscure interesting and/or important physics.  [Previous work by the group of J. Arlt in Denmark](https://link.aps.org/doi/10.1103/PhysRevLett.117.073604) has used dark-field Faraday imaging to non-destructively measure the number of atoms in a sample and then stabilise that number to below the shot-noise limit.  While impressive, it requires an expensive camera to make these measurements, and the use of the camera means that it can only make a measurement every 7 ms.  

[In our work](https://arxiv.org/abs/2102.01773), we have replaced the camera with a pair of avalanche photo-detectors (APDs) to simplify the setup and reduce the cycle time between measurements, which allows us to use an iterative scheme for stabilising the number of atoms.  Setup details can be found in the previous link, but, in short, we use a Red Pitaya FPGA development board to record the voltages produced by the APDs and convert them on-the-fly to a weighted ratio that is insensitive to changes in optical power or APD gain.  This ratio is then proportional to the number of atoms in the sample.

This repository consists of the VHDL source code, as well as a TCL script, for building the FPGA architecture which acquires and processes the APD signals, pulses on the microwave control, and handles the feedback algorithm.  To make it easier to use, a suite of MATLAB classes has been developed that allows for control of the FPGA, and much of this control can be handled via a MATLAB GUI.  Communication between MATLAB and the FPGA is done through the TCP/IP protocol with a Python-based socket server running on the Red Pitaya.  Through this combination of MATLAB and Python, parameters related to the acquisition and feedback can be set, and data from the FPGA can retrieved.

# Overview of FPGA behaviour

The Red Pitaya (RP) expects to have its ADCs connected to the APDs measuring the ouput signals of the polarimeter.  Furthermore, the RP needs to have a rising-edge trigger signal connected to the first pin on the `ext_i` bus, and the output pulse signals associated with lasers L and L' (the so-called 'signal' and 'auxiliary' lines) need to be connected to their respective AOMs.  A shutter output signal is also available if needed.  Finally, there is a microwave output signal that needs to be connected to an appropriate microwave switch.

## Signal acquisition and computation

When the RP receives a rising-edge trigger signal, it immediately triggers the pulse generators (`PulseGen.vhd`) on the signal and auxiliary lines.  These pulse generators have a variable, 32-bit delay counter that allows the auxiliary pulse to be delayed relative to the signal pulse.  The pulses have a user-defined period (32 bits) and pulse width (16 bits), with a programmable number of pulses (16 bits).  These pulse signals are routed to both the output signals to control the AOMs as well as to the next module, `QuickAvg.vhd`.

The `QuickAvg.vhd` module performs a quick, sliding, non-overlapping average of the input ADC signals with the number of samples to average being a power of 2.  The user can set the exponent to essentially downsample the data by more or less points.  On the rising edge of the pulse signal, the module first waits for a programmable delay (14 bits) before starting the averaging process.  This delay is used to account for the non-zero propagation delay of signals from the RP to the associated physical control boxes, as well as the finite travel time of the acoustic waves through the AOMs.  The signal and auxiliary lines can have different delays.  The `QuickAvg` module sums up 2^N points, where N is a 4 bit integer, and then divides by 2^N by shifting the sum N bits to the right.  This occurs for a fixed number of samples (user programmable with 14 bits) before the process stops and waits for the next pulse.  Once the data has been averaged, it is presented on the output data port of the module along with a one clock-cycle active-high valid signal.  For debugging purposes, the first 4096 averaged values on each channel are saved to a block RAM for later retrieval.

The averaged signal is then passed to the `IntegrateADCData.vhd` module which sums the averaged data two windows before subtracting these two sums.  The first summation region should occur when light is present on the APD, and the second summation region should occur when there is no light.  The difference between these then allows for a measure of the signal relative to a possibly changing baseline voltage on the RP.  The regions of summation and subtraction are specified by 11-bit starting points `sumStart` and `subStart`, respectively, with an 10 bit width `width` that is common between them.  The width is common so that one does not need to implement division to ensure that the scales of the summation and subtraction regions are the same.  Once the subtraction has occurred, this data is presented on the output of the module with a single clock-cycle active-high valid signal.  Like the averaged data, the integrated data is also saved in a block RAM for later retrieval.

The integrated data on both the signal and auxiliary lines are then fed into the module `ComputeSignal.vhd` which waits until it gets valid signals from both the signal and auxiliary lines and then proceeds to compute the signal R (as in Eq. 4 in the arXiv paper).  This involves two multiplications and one division, and has a latency of nearly 100 clock cycles.  The ratio value R is computed to 16 bits of precision, and is presented on the output along with a valid signal.  R is saved in a block memory for later retrieval.

## Feedback

The `NumberStabilisation.vhd` controls the signals necessary for stabilising the number of atoms.  Input registers carry the target ratio (24 bits), the tolerance value below which feeback stops (24 bits), and the maximum number of microwave pulses (16 bits).  In addition, the microwave pulse width (16 bits) and period (32 bits) are set along with a manual number of microwave pulses (16 bits) for testing purposes.

This takes in the current ratio value and a one clock-cycle active-high valid signal. When feedback is enabled (input using the `cntrl_i.enable` port), the module computes the number of microwave pulses to output using the target ratio and the current ratio as well as the maximum number of pulses.  Feedback is attempted until the current ratio value is less than the tolerance.

# Communication between FPGA and operating system

## Hardware description

Communication between the FPGA and the Linux operating system is done through a memory-mapped AXI bus.  Available addresses range from 0x40000000 to 0x4FFFFFFF.  In reality, the AXI bus is far too complicated for the use to which it is put in this device, so we use a Xilinx AXI protocol converter to convert the AXI4 bus to an AXI4-Lite bus.  Even this is, for the most part, too complicated for what we need, so a special module called `AXI_Parse.vhd` converts the AXI4-Lite bus into a 5 signal interface with output signals `addr_o`, `dataValid_o`, and `writeData_o`, and input signals `readData_i` and `resp_i`.  The `addr_o` signal indicates the address that the OS is trying to access, relative to the starting address of 0x40000000.  `dataValid_o` is a two-bit signal where bit 0 is high for one clock cycle when `writeData_o` (the data from the OS) and `addr_o` are valid, and bit 1 indicates if it is a write operation (low) or a read operation (high).  The `readData_i` signal is the data being sent to the OS, and `resp_i` is a two-bit signal where bit 0 indicates that the transaction has completed and that `readData_i` is valid in the case of a read operation, and bit 1 is high only when an error has occurred.  Currently, errors occur only when an address is accessed that is not implemented in the main parsing process in `topmod.vhd`.

To simplify the code and improve code maintenance, many of the AXI related signals and processes are packaged up in the `AXI_Bus_Package.vhd` package.  This package defines the data types `t_axi_bus_master` and `t_axi_bus_slave` which can be combined into the bus type `t_axi_bus`.  The master and slave buses are used as inputs and outputs to overloaded `rw` processes which are used for handling the reading and writing of various parameter registers in the project, uniformly implemented as 32-bit `std_logic_vector` types as the sub-type `t_param_reg` (in packaged `CustomDataTypes.vhd`).

Parameter parsing is handled in the process `Parse` in the module `topmod.vhd`. This is a finite state machine with 3 states (aside from the reset state): `idle`, `processing`, and `finishing`.  When in `idle`, it waits for a AXI bus to signal that new data is available/requested.  It then moves to processing, which is a large `case` statement that sorts through different addresses to read from/write to different parameters, or read from one of the block RAMs used for storing data.  When done, it moves to the `finishing` state where it sets all single clock-cycle triggers to zero and then moves back to the `idle` state.

One will note that addresses must be aligned with 4-byte boundaries, as the AXI interface assumes that 32 bits of data will be written/read at all times.  One can get around this if necessary, but it was not implemented and thus all data written to the FPGA must be 32 bits wide and addresses used for accessing memory locations in the FPGA must also be aligned with 4-byte word boundaries; i.e., the address must end in either 0, 4, 8, or C.

## Software description

Low-level communication with the FPGA is handled by programs written in C.  For dealing with simple parameters where we only need relatively slow read/write speeds, we use the `monitor` program that is packaged with the Red Pitaya OS.  This allows for a very simple writing to and reading from the FPGA.  One invokves it thusly
```
monitor <addr> <data>
```
where `<addr>` is the memory address to access specified as an unsigned integer, and `<data>` is the data to write, also as an unsigned integer.  If data is absent, it is considered a read operation and the current value at the specified `<addr>` is printed to the command line.  Both `<addr>` and `<data>` can be specified in hexadecimal format like so
```
monitor 0x40000000
monitor 0x40000004 0x54
```
where the first line reads from memory address `0x40000000` and the second line writes the data `0x54` to memory address `0x40000004`.  

When reading from the block RAMs we want to read a lot of data in a short amount of time.  In this case we use a custom function `fetchData` (source `fetchData.c`) to read data from the FPGA.  This program uses two arguments: the number of samples to fetch and the RAM to fetch from.  The maximum number of samples to fetch is 16384.  The `fetchType` parameter, which is the second argument, has possible values [0,4] in integer steps, with 0 and 1 fetching raw data from the signal and auxiliary lines, respectively; values 2 and 3 fetching integrated data from the signal and auxiliary lines, respectively; and value 4 fetching the computed ratio.  The raw data is 16 bits internally in the FPGA so the two channels are concatenated into a single 32 bit data word.  The integrated data is 24 bits wide, so the two channels are interleaved as separate addresses in the block RAMs and retrieved as such.  The ratio data is 16 bits wide and thus is stored as one entry per address.

